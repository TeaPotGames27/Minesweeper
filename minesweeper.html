
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minesweeper â€” Playable Offline</title>
<style>
  :root {
    --bg: #f3f4f6;
    --cell: #e6eef6;
    --cell-dark: #d0d7de;
    --text: #0f172a;
    --accent: #0ea5a4;
  }
  body{font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#f8fafc, #eef2ff); color:var(--text)}
  .board-wrap{width:min(92vw,760px); padding:18px; background:white; border-radius:12px; box-shadow:0 6px 30px rgba(10,10,20,0.08)}
  header{display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:12px}
  .title{font-size:1.25rem; font-weight:700}
  .controls{display:flex; gap:8px; align-items:center}
  .btn{background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600}
  .btn.secondary{background:#64748b}
  .status{display:flex; gap:8px; align-items:center}
  .stat{background:#0f172a10; padding:6px 10px; border-radius:8px; font-weight:700; min-width:56px; text-align:center}
  #grid{display:grid; gap:4px; justify-content:center; margin-top:10px}
  .cell{width:36px; height:36px; display:flex; align-items:center; justify-content:center; background:var(--cell); border-radius:6px; user-select:none; font-weight:700; cursor:pointer; box-shadow: 0 2px 0 rgba(255,255,255,0.6) inset}
  .cell.revealed{background:var(--cell-dark); cursor:default; box-shadow:none}
  .cell.mine{background:#f87171; color:white}
  .cell.flag{background:#fde68a}
  .cell.num-1{color:#2563eb}
  .cell.num-2{color:#16a34a}
  .cell.num-3{color:#dc2626}
  .cell.num-4{color:#7c3aed}
  .cell.num-5{color:#b45309}
  .cell.num-6{color:#0891b2}
  .cell.num-7{color:#1f2937}
  .cell.num-8{color:#374151}
  .footer{margin-top:12px; font-size:0.9rem; color:#475569}
  input[type=number]{width:60px; padding:6px 8px; border-radius:8px; border:1px solid #cbd5e1}
  select{padding:6px 8px; border-radius:8px; border:1px solid #cbd5e1}
  .small{font-size:0.85rem; color:#475569}
  @media (max-width:420px){
    .cell{width:30px;height:30px;font-size:0.95rem}
  }
</style>
</head>
<body>
  <div class="board-wrap" role="application" aria-labelledby="title">
    <header>
      <div>
        <div id="title" class="title">Minesweeper â€” Play &amp; Share</div>
        <div class="small">Left-click to reveal â€¢ Right-click to flag</div>
      </div>
      <div class="controls">
        <div class="status">
          <div class="stat" id="mines-left">Mines: 0</div>
          <div class="stat" id="timer">00:00</div>
        </div>
        <button class="btn" id="reset">New</button>
      </div>
    </header>

    <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
      <label>Preset:
        <select id="preset">
          <option value="beginner">Beginner â€” 9Ã—9, 10 mines</option>
          <option value="intermediate">Intermediate â€” 16Ã—16, 40 mines</option>
          <option value="expert">Expert â€” 16Ã—30, 99 mines</option>
          <option value="custom">Custom</option>
        </select>
      </label>
      <label>Rows: <input type="number" id="rows" min="5" max="30" value="9"></label>
      <label>Cols: <input type="number" id="cols" min="5" max="50" value="9"></label>
      <label>Mines: <input type="number" id="mines" min="1" value="10"></label>
      <button class="btn secondary" id="share">Get link</button>
    </div>

    <div id="grid" role="grid" aria-label="Minesweeper grid"></div>

    <div class="footer">
      Tip: the first click is always safe. You can drag to reveal multiple neighbors if you like â€” or use single clicks.
    </div>
  </div>

<script>
(function(){
  // Utilities
  const qs = s => document.querySelector(s);
  const qsa = s => Array.from(document.querySelectorAll(s));
  const gridEl = qs('#grid');
  const minesLeftEl = qs('#mines-left');
  const timerEl = qs('#timer');
  const resetBtn = qs('#reset');
  const preset = qs('#preset');
  const rowsInput = qs('#rows');
  const colsInput = qs('#cols');
  const minesInput = qs('#mines');
  const shareBtn = qs('#share');

  let rows = 9, cols = 9, totalMines = 10;
  let board = []; // cells: {r,c,isMine,adj,revealed,flagged}
  let firstClick = true;
  let timer = null, seconds = 0;
  let remainingFlags = 0;
  let revealedCount = 0;
  let gameOver = false;

  function setPreset(p){
    if(p==='beginner'){ rows=9; cols=9; totalMines=10; }
    else if(p==='intermediate'){ rows=16; cols=16; totalMines=40; }
    else if(p==='expert'){ rows=16; cols=30; totalMines=99; }
    else if(p==='custom'){ /* keep current inputs */ }
    rowsInput.value = rows; colsInput.value = cols; minesInput.value = totalMines;
    build();
  }
  preset.addEventListener('change', e=> setPreset(e.target.value));
  rowsInput.addEventListener('change', buildInputs);
  colsInput.addEventListener('change', buildInputs);
  minesInput.addEventListener('change', buildInputs);

  function buildInputs(){
    rows = Math.max(5, Math.min(30, parseInt(rowsInput.value)||9));
    cols = Math.max(5, Math.min(50, parseInt(colsInput.value)||9));
    totalMines = Math.max(1, Math.min(rows*cols-1, parseInt(minesInput.value)||10));
    rowsInput.value = rows; colsInput.value = cols; minesInput.value = totalMines;
    preset.value = 'custom';
    build();
  }

  function resetTimer(){
    clearInterval(timer); timer=null; seconds=0; timerEl.textContent = "00:00";
  }
  function startTimer(){
    if(timer) return;
    timer = setInterval(()=>{
      seconds++;
      const mm = String(Math.floor(seconds/60)).padStart(2,'0');
      const ss = String(seconds%60).padStart(2,'0');
      timerEl.textContent = mm+":"+ss;
    },1000);
  }

  function build(){
    resetTimer();
    firstClick = true;
    gameOver = false;
    revealedCount = 0;
    remainingFlags = totalMines;
    minesLeftEl.textContent = 'Mines: ' + remainingFlags;
    board = [];
    gridEl.innerHTML = '';
    gridEl.style.gridTemplateColumns = `repeat(${cols}, auto)`;
    gridEl.style.gridTemplateRows = `repeat(${rows}, auto)`;
    for(let r=0;r<rows;r++){
      board[r]=[];
      for(let c=0;c<cols;c++){
        const cell = {r,c,isMine:false,adj:0,revealed:false,flagged:false,el:null};
        const el = document.createElement('div');
        el.className='cell';
        el.dataset.r=r; el.dataset.c=c;
        el.setAttribute('role','button');
        el.setAttribute('aria-label',`cell ${r+1},${c+1}`);
        el.addEventListener('click', onLeftClick);
        el.addEventListener('contextmenu', onRightClick);
        el.addEventListener('mousedown', e=> e.preventDefault());
        cell.el = el;
        board[r][c]=cell;
        gridEl.appendChild(el);
      }
    }
    // Adjust cell size to fit width
    requestAnimationFrame(()=> {
      const wrapW = gridEl.clientWidth;
      const cellW = Math.floor(Math.min(44, (wrapW - (cols-1)*4) / cols));
      qsa('.cell').forEach(x => { x.style.width = cellW + 'px'; x.style.height = cellW + 'px'; });
    });
  }

  function neighbors(r,c){
    const res=[];
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        if(dr===0 && dc===0) continue;
        const nr=r+dr, nc=c+dc;
        if(nr>=0 && nr<rows && nc>=0 && nc<cols) res.push(board[nr][nc]);
      }
    }
    return res;
  }

  function placeMines(safeR, safeC){
    // place totalMines mines excluding the safe cell and its neighbors
    const forbidden = new Set();
    forbidden.add(`${safeR},${safeC}`);
    neighbors(safeR,safeC).forEach(n=> forbidden.add(`${n.r},${n.c}`));
    let placed=0;
    while(placed<totalMines){
      const r = Math.floor(Math.random()*rows);
      const c = Math.floor(Math.random()*cols);
      if(forbidden.has(`${r},${c}`)) continue;
      if(board[r][c].isMine) continue;
      board[r][c].isMine=true;
      placed++;
    }
    // compute adj counts
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(board[r][c].isMine) continue;
        board[r][c].adj = neighbors(r,c).filter(n=>n.isMine).length;
      }
    }
  }

  function reveal(cell){
    if(gameOver || cell.revealed || cell.flagged) return;
    cell.revealed = true;
    revealedCount++;
    const el = cell.el;
    el.classList.add('revealed');
    if(cell.isMine){
      el.classList.add('mine');
      el.textContent = 'ðŸ’£';
      lose('BOOM! You hit a mine.');
      return;
    }
    if(cell.adj>0){
      el.textContent = cell.adj;
      el.classList.add('num-'+cell.adj);
    } else {
      // empty â€” reveal neighbors
      el.textContent = '';
      neighbors(cell.r, cell.c).forEach(n => { if(!n.revealed && !n.flagged) reveal(n); });
    }
    checkWin();
  }

  function onLeftClick(e){
    const r = +this.dataset.r, c = +this.dataset.c;
    const cell = board[r][c];
    if(gameOver) return;
    if(firstClick){
      placeMines(r,c);
      startTimer();
      firstClick=false;
    }
    // If clicked revealed cell with adj and flags equal adj, chord
    if(cell.revealed && cell.adj>0){
      const flaggedNeighbors = neighbors(r,c).filter(n=>n.flagged).length;
      if(flaggedNeighbors === cell.adj){
        neighbors(r,c).forEach(n=> { if(!n.flagged) reveal(n); });
      }
      return;
    }
    reveal(cell);
  }

  function onRightClick(e){
    e.preventDefault();
    const r = +this.dataset.r, c = +this.dataset.c;
    const cell = board[r][c];
    if(gameOver || cell.revealed) return;
    cell.flagged = !cell.flagged;
    if(cell.flagged){
      cell.el.classList.add('flag');
      cell.el.textContent = 'ðŸš©';
      remainingFlags--;
    } else {
      cell.el.classList.remove('flag');
      cell.el.textContent = '';
      remainingFlags++;
    }
    minesLeftEl.textContent = 'Mines: ' + remainingFlags;
    checkWin();
  }

  function revealAllMines(){
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = board[r][c];
        if(cell.isMine && !cell.revealed){
          cell.revealed=true;
          cell.el.classList.add('revealed','mine');
          cell.el.textContent='ðŸ’£';
        }
      }
    }
  }

  function lose(msg){
    gameOver = true;
    clearInterval(timer);
    revealAllMines();
    setTimeout(()=> alert(msg + "\\nPress New to play again."), 50);
  }

  function checkWin(){
    // Win when all non-mine cells revealed OR all mines flagged correctly and flags used equals mines
    const totalCells = rows*cols;
    const nonMine = totalCells - totalMines;
    if(revealedCount === nonMine){
      gameOver = true;
      clearInterval(timer);
      setTimeout(()=> alert('ðŸŽ‰ You won! Time: ' + timerEl.textContent), 50);
    }
  }

  resetBtn.addEventListener('click', ()=> {
    rows = Math.max(5, Math.min(30, parseInt(rowsInput.value)||9));
    cols = Math.max(5, Math.min(50, parseInt(colsInput.value)||9));
    totalMines = Math.max(1, Math.min(rows*cols-1, parseInt(minesInput.value)||10));
    build();
  });

  // Share: encode parameters and a seed if desired
  function makeShareLink(){
    const params = new URLSearchParams();
    params.set('r', rows);
    params.set('c', cols);
    params.set('m', totalMines);
    // encode board state? We'll just share params so others can play same size
    const url = location.href.split('#')[0].split('?')[0] + '?' + params.toString();
    return url;
  }

  shareBtn.addEventListener('click', ()=>{
    const link = makeShareLink();
    navigator.clipboard?.writeText(link).then(()=> {
      alert('Link copied! Paste it in a new tab to open the same board size.');
    }).catch(()=> {
      prompt('Copy this link:', link);
    });
  });

  // read URL params to set size
  function readParams(){
    try{
      const p = new URLSearchParams(location.search);
      const r = parseInt(p.get('r')); const c = parseInt(p.get('c')); const m = parseInt(p.get('m'));
      if(Number.isInteger(r) && Number.isInteger(c) && Number.isInteger(m)){
        rows = Math.max(5, Math.min(30, r));
        cols = Math.max(5, Math.min(50, c));
        totalMines = Math.max(1, Math.min(rows*cols-1, m));
      }
    }catch(e){}
    rowsInput.value = rows; colsInput.value = cols; minesInput.value = totalMines;
  }

  // init
  readParams();
  build();

  // Accessibility: keyboard navigation (arrow keys + Enter to reveal + F to flag)
  let selected = {r:0,c:0};
  function focusCell(r,c){
    qsa('.cell').forEach(x=>x.classList.remove('focused'));
    const el = board[r][c].el;
    el.classList.add('focused');
    el.scrollIntoView({block:'nearest', inline:'nearest'});
  }
  document.addEventListener('keydown', (e)=>{
    if(gameOver) return;
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter',' ' ,'f','F'].includes(e.key)){
      e.preventDefault();
    } else return;
    if(e.key === 'ArrowUp') selected.r = (selected.r-1+rows)%rows;
    if(e.key === 'ArrowDown') selected.r = (selected.r+1)%rows;
    if(e.key === 'ArrowLeft') selected.c = (selected.c-1+cols)%cols;
    if(e.key === 'ArrowRight') selected.c = (selected.c+1+cols)%cols;
    focusCell(selected.r, selected.c);
    if(e.key === 'Enter' || e.key === ' '){
      board[selected.r][selected.c].el.click();
    }
    if(e.key === 'f' || e.key === 'F'){
      board[selected.r][selected.c].el.dispatchEvent(new Event('contextmenu', {bubbles:true, cancelable:true}));
    }
  });

})();
</script>
</body>
</html>
